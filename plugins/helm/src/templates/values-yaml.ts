/**
 * values.yaml Generator
 *
 * Generates default values from resolved K8s resources
 */

import type { HelmValues, DeploymentValues } from '../types';
import type { ResolvedResource } from '@stacksolo/core';

export interface ValuesYamlOptions {
  chartName: string;
  resources: ResolvedResource[];
  defaultRegistry?: string;
}

export function generateValuesYaml(options: ValuesYamlOptions): string {
  const values = extractValues(options);
  return serializeYaml(values);
}

function extractValues(options: ValuesYamlOptions): HelmValues {
  const { resources, defaultRegistry } = options;

  // Extract deployments from resources
  const deployments: Record<string, DeploymentValues> = {};
  const ingressRoutes: Array<{ path: string; backend: string; port: number }> = [];
  const configData: Record<string, string> = {};
  let ingressEnabled = false;
  let ingressClassName = 'nginx';
  let ingressHost: string | undefined;
  let ingressTlsSecretName: string | undefined;

  for (const resource of resources) {
    if (resource.type === 'k8s:deployment') {
      const config = resource.config as Record<string, unknown>;
      const name = config.name as string;
      // Extract short name (remove project prefix if present)
      const shortName = name.split('-').slice(-1)[0] || name;

      const image = config.image as string || '';
      const [repository, tag] = parseImage(image, defaultRegistry);

      deployments[shortName] = {
        enabled: true,
        replicaCount: (config.replicas as number) || 1,
        image: {
          repository,
          tag,
        },
        port: (config.port as number) || 8080,
        servicePort: 80,
        env: (config.env as Record<string, string>) || {},
      };

      // Check for custom resources
      if (config.memory || config.cpu) {
        deployments[shortName].resources = {
          limits: {
            cpu: (config.cpu as string) || '500m',
            memory: (config.memory as string) || '512Mi',
          },
          requests: {
            cpu: '100m',
            memory: '128Mi',
          },
        };
      }
    }

    if (resource.type === 'k8s:configmap') {
      const config = resource.config as Record<string, unknown>;
      const data = (config.data as Record<string, string>) || {};
      Object.assign(configData, data);
    }

    if (resource.type === 'k8s:ingress') {
      ingressEnabled = true;
      const config = resource.config as Record<string, unknown>;
      ingressClassName = (config.className as string) || 'nginx';
      ingressHost = config.host as string | undefined;
      ingressTlsSecretName = config.tlsSecretName as string | undefined;

      const routes = (config.routes as Array<{ path: string; backend: string }>) || [];
      for (const route of routes) {
        ingressRoutes.push({
          path: route.path || '/',
          backend: route.backend,
          port: 80,
        });
      }
    }
  }

  return {
    replicaCount: 1,
    image: {
      pullPolicy: 'IfNotPresent',
    },
    resources: {
      limits: {
        cpu: '500m',
        memory: '512Mi',
      },
      requests: {
        cpu: '100m',
        memory: '128Mi',
      },
    },
    ingress: {
      enabled: ingressEnabled,
      className: ingressClassName,
      host: ingressHost,
      tlsSecretName: ingressTlsSecretName,
      annotations: {},
      routes: ingressRoutes,
    },
    config: configData,
    deployments,
  };
}

function parseImage(image: string, defaultRegistry?: string): [string, string] {
  if (!image) {
    return [defaultRegistry ? `${defaultRegistry}/app` : 'app', 'latest'];
  }

  const parts = image.split(':');
  const repository = parts[0];
  const tag = parts[1] || 'latest';

  return [repository, tag];
}

function serializeYaml(values: HelmValues): string {
  const lines: string[] = [];

  lines.push(`# Default values for the Helm chart`);
  lines.push(`# Generated by StackSolo`);
  lines.push(``);
  lines.push(`replicaCount: ${values.replicaCount}`);
  lines.push(``);
  lines.push(`image:`);
  lines.push(`  pullPolicy: ${values.image.pullPolicy}`);
  lines.push(``);
  lines.push(`resources:`);
  lines.push(`  limits:`);
  lines.push(`    cpu: ${values.resources.limits.cpu}`);
  lines.push(`    memory: ${values.resources.limits.memory}`);
  lines.push(`  requests:`);
  lines.push(`    cpu: ${values.resources.requests.cpu}`);
  lines.push(`    memory: ${values.resources.requests.memory}`);
  lines.push(``);
  lines.push(`serviceAccount:`);
  lines.push(`  create: false`);
  lines.push(`  name: ""`);
  lines.push(``);
  lines.push(`ingress:`);
  lines.push(`  enabled: ${values.ingress.enabled}`);
  lines.push(`  className: "${values.ingress.className}"`);
  if (values.ingress.host) {
    lines.push(`  host: "${values.ingress.host}"`);
  }
  if (values.ingress.tlsSecretName) {
    lines.push(`  tlsSecretName: "${values.ingress.tlsSecretName}"`);
  }
  lines.push(`  annotations: {}`);
  if (values.ingress.routes.length > 0) {
    lines.push(`  routes:`);
    for (const route of values.ingress.routes) {
      lines.push(`    - path: "${route.path}"`);
      lines.push(`      backend: "${route.backend}"`);
      lines.push(`      port: ${route.port}`);
    }
  } else {
    lines.push(`  routes: []`);
  }
  lines.push(``);

  if (Object.keys(values.config).length > 0) {
    lines.push(`config:`);
    for (const [key, value] of Object.entries(values.config)) {
      lines.push(`  ${key}: "${value}"`);
    }
    lines.push(``);
  } else {
    lines.push(`config: {}`);
    lines.push(``);
  }

  lines.push(`# Per-deployment configuration`);
  lines.push(`deployments:`);
  for (const [name, deployment] of Object.entries(values.deployments)) {
    lines.push(`  ${name}:`);
    lines.push(`    enabled: ${deployment.enabled}`);
    if (deployment.replicaCount) {
      lines.push(`    replicaCount: ${deployment.replicaCount}`);
    }
    lines.push(`    image:`);
    lines.push(`      repository: "${deployment.image.repository}"`);
    lines.push(`      tag: "${deployment.image.tag}"`);
    lines.push(`    port: ${deployment.port}`);
    lines.push(`    servicePort: ${deployment.servicePort || 80}`);
    if (Object.keys(deployment.env).length > 0) {
      lines.push(`    env:`);
      for (const [key, value] of Object.entries(deployment.env)) {
        lines.push(`      ${key}: "${value}"`);
      }
    } else {
      lines.push(`    env: {}`);
    }
    if (deployment.resources) {
      lines.push(`    resources:`);
      if (deployment.resources.limits) {
        lines.push(`      limits:`);
        if (deployment.resources.limits.cpu) {
          lines.push(`        cpu: ${deployment.resources.limits.cpu}`);
        }
        if (deployment.resources.limits.memory) {
          lines.push(`        memory: ${deployment.resources.limits.memory}`);
        }
      }
      if (deployment.resources.requests) {
        lines.push(`      requests:`);
        if (deployment.resources.requests.cpu) {
          lines.push(`        cpu: ${deployment.resources.requests.cpu}`);
        }
        if (deployment.resources.requests.memory) {
          lines.push(`        memory: ${deployment.resources.requests.memory}`);
        }
      }
    } else {
      lines.push(`    resources: {}`);
    }
  }

  return lines.join('\n') + '\n';
}
