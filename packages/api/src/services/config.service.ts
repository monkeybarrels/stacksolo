import * as fs from 'fs/promises';
import * as path from 'path';
import type { Project } from '@stacksolo/shared';
import type { AppPattern } from '@stacksolo/core';

export interface ResourceOutputs {
  [resourceName: string]: {
    outputs?: Record<string, string>;
  };
}

export class ConfigService {
  /**
   * Generate configuration files for a project after deployment
   * Creates .env.local and stacksolo.config.ts in the project directory
   */
  async generateConfig(
    project: Project,
    pattern: AppPattern,
    resourceOutputs: ResourceOutputs
  ): Promise<{ envPath: string; configPath: string }> {
    if (!project.path) {
      throw new Error('Project path is required for config generation');
    }

    // Generate environment variables from pattern
    const envVars = pattern.env(resourceOutputs);

    // Generate .env.local
    const envContent = this.generateEnvFile(envVars);
    const envPath = path.join(project.path, '.env.local');
    await fs.writeFile(envPath, envContent, 'utf-8');

    // Generate stacksolo.config.ts
    const configContent = this.generateConfigFile(envVars, pattern);
    const configPath = path.join(project.path, 'stacksolo.config.ts');
    await fs.writeFile(configPath, configContent, 'utf-8');

    return { envPath, configPath };
  }

  /**
   * Generate .env.local file content
   */
  private generateEnvFile(envVars: Record<string, string>): string {
    const lines = [
      '# Generated by StackSolo - Do not edit manually',
      '# Regenerate with: stacksolo generate-config',
      '',
    ];

    for (const [key, value] of Object.entries(envVars)) {
      // Escape special characters and quote if needed
      const escapedValue = this.escapeEnvValue(value);
      lines.push(`${key}=${escapedValue}`);
    }

    lines.push(''); // trailing newline
    return lines.join('\n');
  }

  /**
   * Escape environment variable value for .env file
   */
  private escapeEnvValue(value: string): string {
    if (!value) return '""';

    // If value contains special characters, quote it
    if (
      value.includes(' ') ||
      value.includes('"') ||
      value.includes("'") ||
      value.includes('\n') ||
      value.includes('$')
    ) {
      // Escape double quotes and wrap in double quotes
      return `"${value.replace(/"/g, '\\"')}"`;
    }

    return value;
  }

  /**
   * Generate stacksolo.config.ts file content
   */
  private generateConfigFile(
    envVars: Record<string, string>,
    pattern: AppPattern
  ): string {
    const envKeys = Object.keys(envVars);

    // Build the config interface based on what resources the pattern uses
    const hasDatabase = envKeys.some((k) => k.includes('DATABASE'));
    const hasStorage = envKeys.some((k) => k.includes('STORAGE') || k.includes('BUCKET'));
    const hasAppUrl = envKeys.some((k) => k.includes('APP_URL') || k.includes('URL'));

    const lines = [
      '// Generated by StackSolo - Do not edit manually',
      '// Regenerate with: stacksolo generate-config',
      '',
      "import { createStackSoloConfig } from '@stacksolo/runtime';",
      '',
      'export const config = createStackSoloConfig({',
    ];

    // Add database config if present
    if (hasDatabase) {
      const dbKey = envKeys.find((k) => k.includes('DATABASE_URL')) || 'DATABASE_URL';
      lines.push(`  database: {`);
      lines.push(`    url: process.env.${dbKey}!,`);
      lines.push(`  },`);
    }

    // Add storage config if present
    if (hasStorage) {
      const bucketKey = envKeys.find((k) =>
        k.includes('STORAGE_BUCKET') || k.includes('BUCKET')
      ) || 'STORAGE_BUCKET';
      lines.push(`  storage: {`);
      lines.push(`    bucket: process.env.${bucketKey}!,`);
      lines.push(`  },`);
    }

    // Add app config if present
    if (hasAppUrl) {
      const urlKey = envKeys.find((k) => k.includes('APP_URL')) || 'APP_URL';
      lines.push(`  app: {`);
      lines.push(`    url: process.env.${urlKey}!,`);
      lines.push(`  },`);
    }

    lines.push('});');
    lines.push('');

    // Add helper exports
    lines.push('// Helper functions');
    lines.push('');

    if (hasDatabase) {
      lines.push('/**');
      lines.push(' * Get database connection URL');
      lines.push(' * @throws Error if DATABASE_URL is not set');
      lines.push(' */');
      lines.push('export function getDatabaseUrl(): string {');
      lines.push('  const url = process.env.DATABASE_URL;');
      lines.push("  if (!url) throw new Error('DATABASE_URL environment variable is not set');");
      lines.push('  return url;');
      lines.push('}');
      lines.push('');
    }

    if (hasStorage) {
      lines.push('/**');
      lines.push(' * Get storage bucket name');
      lines.push(' */');
      lines.push('export function getStorageBucket(): string | undefined {');
      const bucketKey = envKeys.find((k) =>
        k.includes('STORAGE_BUCKET') || k.includes('BUCKET')
      ) || 'STORAGE_BUCKET';
      lines.push(`  return process.env.${bucketKey};`);
      lines.push('}');
      lines.push('');
    }

    // Add validation function
    lines.push('/**');
    lines.push(' * Validate that all required environment variables are set');
    lines.push(' * Call this at app startup to fail fast if config is incomplete');
    lines.push(' */');
    lines.push('export function validateConfig(): void {');
    lines.push('  const missing: string[] = [];');
    lines.push('');

    for (const key of envKeys) {
      if (key === 'NODE_ENV') continue; // Skip NODE_ENV as it's often not required
      lines.push(`  if (!process.env.${key}) missing.push('${key}');`);
    }

    lines.push('');
    lines.push('  if (missing.length > 0) {');
    lines.push("    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);");
    lines.push('  }');
    lines.push('}');
    lines.push('');

    // Export pattern info for debugging
    lines.push('// Pattern metadata');
    lines.push(`export const STACKSOLO_PATTERN = '${pattern.id}';`);
    lines.push(`export const STACKSOLO_PROVIDER = '${pattern.provider}';`);
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Read existing .env.local and merge with new values
   * Preserves user-added variables that don't conflict
   */
  async mergeEnvFile(
    projectPath: string,
    newEnvVars: Record<string, string>
  ): Promise<string> {
    const envPath = path.join(projectPath, '.env.local');
    let existingVars: Record<string, string> = {};

    try {
      const content = await fs.readFile(envPath, 'utf-8');
      existingVars = this.parseEnvFile(content);
    } catch {
      // File doesn't exist, start fresh
    }

    // Merge: new values take precedence
    const merged = { ...existingVars, ...newEnvVars };
    return this.generateEnvFile(merged);
  }

  /**
   * Parse .env file content into key-value pairs
   */
  private parseEnvFile(content: string): Record<string, string> {
    const vars: Record<string, string> = {};
    const lines = content.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();

      // Skip comments and empty lines
      if (!trimmed || trimmed.startsWith('#')) continue;

      const eqIndex = trimmed.indexOf('=');
      if (eqIndex === -1) continue;

      const key = trimmed.slice(0, eqIndex);
      let value = trimmed.slice(eqIndex + 1);

      // Remove surrounding quotes if present
      if (
        (value.startsWith('"') && value.endsWith('"')) ||
        (value.startsWith("'") && value.endsWith("'"))
      ) {
        value = value.slice(1, -1);
      }

      vars[key] = value;
    }

    return vars;
  }
}
